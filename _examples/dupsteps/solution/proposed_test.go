package solution

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"testing"

	"github.com/cucumber/godog"
	"github.com/cucumber/godog/internal/formatters"
	"github.com/stretchr/testify/assert"
)

//
//  Demonstration of an approach to produce a single aggregated report from runs of separate test suites
//  (e.g., `godog.TestSuite` instances), using standard `go` test cases.  See associated README file.
//

// the single global var needed to "collect" the output(s) produced by the test(s)
var mw = multiWriter{}

// the main test "scaffold" which runs the test case(s), then finally aggregates the outputs into a single report

func TestMain(m *testing.M) {
	rc := m.Run() // runs the test case(s)

	// then invokes a "combiner" appropriate for the output(s) produced by the test case(s)
	// NOTE: the "combiner" is formatter-specific; this one "knows" to combine "cucumber" reports
	outputs, err := combineCukeOutputs(mw.getOutputs())
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "combiner error: %s\n", err)
	} else {
		// hmm, it'd be nice to have some CLI options to control this destination...
		fmt.Println(string(outputs))
	}

	os.Exit(rc)
}

// one or more test case(s), providing the desired level of step encapsulation

func TestFlatTire(t *testing.T) {
	opts := defaultOpts

	// test runs only selected features/scenarios
	opts.Paths = []string{"../features/flatTire.feature"}
	opts.Output = mw.newOutput()

	gts := godog.TestSuite{
		Name: t.Name(),
		ScenarioInitializer: func(ctx *godog.ScenarioContext) {
			ctx.Step(`^I ran over a nail and got a flat tire$`, func() {})
			ctx.Step(`^I fixed it$`, func() {})
			ctx.Step(`^I can continue on my way$`, func() {})
		},
		Options: &opts,
	}

	assert.Zero(t, gts.Run())
}

func TestCloggedDrain(t *testing.T) {
	opts := defaultOpts

	// test runs only selected features/scenarios
	opts.Paths = []string{"../features/cloggedDrain.feature"}
	opts.Output = mw.newOutput()

	gts := godog.TestSuite{
		Name: t.Name(),
		ScenarioInitializer: func(ctx *godog.ScenarioContext) {
			ctx.Step(`^I accidentally poured concrete down my drain and clogged the sewer line$`, func() {})
			ctx.Step(`^I fixed it$`, func() {})
			ctx.Step(`^I can once again use my sink$`, func() {})

		},
		Options: &opts,
	}

	assert.Zero(t, gts.Run())
}

// multi writer utility used to collect output generated by the test case(s)

type multiWriter struct {
	bufs []*bytes.Buffer
}

func (w *multiWriter) newOutput() *bytes.Buffer {
	buf := &bytes.Buffer{}

	w.bufs = append(w.bufs, buf)

	return buf
}

func (w *multiWriter) getOutputs() [][]byte {
	outputs := make([][]byte, 0, len(w.bufs))

	for _, buf := range w.bufs {
		outputs = append(outputs, buf.Bytes())
	}

	return outputs
}

// cucumber combiner - "knows" how to combine multiple "cucumber" reports into one

func combineCukeOutputs(outputs [][]byte) ([]byte, error) {
	var result []formatters.CukeFeatureJSON

	for _, output := range outputs {
		var cukeFeatureJSONS []formatters.CukeFeatureJSON

		err := json.Unmarshal(output, &cukeFeatureJSONS)
		if err != nil {
			return nil, fmt.Errorf("can't unmarshal cuke feature JSON: %w", err)
		}

		result = append(result, cukeFeatureJSONS...)
	}

	aggregatedResults, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		return nil, fmt.Errorf("can't marshal combined cuke feature JSON: %w", err)
	}

	return aggregatedResults, nil
}

func init() {
	// allow user overrides of preferred godog defaults via command-line flags
	godog.BindFlags("godog.", flag.CommandLine, &defaultOpts)
}

// holds preferred godog defaults to be used by the test case(s)
var defaultOpts = godog.Options{
	Strict: true,
	Format: "cucumber",
}
